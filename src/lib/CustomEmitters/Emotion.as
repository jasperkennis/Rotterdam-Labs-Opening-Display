package lib.CustomEmitters{	import flash.geom.Point;	import org.flintparticles.common.counters.Blast;	import org.flintparticles.common.displayObjects.Dot;	import org.flintparticles.common.displayObjects.Rect;	import org.flintparticles.common.particles.Particle;	import org.flintparticles.common.initializers.*;	import org.flintparticles.twoD.actions.*;	import org.flintparticles.twoD.emitters.Emitter2D;	import org.flintparticles.twoD.initializers.*;	import org.flintparticles.twoD.zones.*;	import org.flintparticles.threeD.initializers.RotateVelocity;	import org.flintparticles.twoD.actions.Rotate;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.display.Stage;	import flash.text.TextField;	import flash.geom.Matrix;	import flash.text.TextFormat;	import org.flintparticles.common.events.ParticleEvent;	import flashx.textLayout.formats.ITabStopFormat;	import org.flintparticles.threeD.actions.TweenToZone;	import org.flintparticles.threeD.initializers.Velocity;	/**	 * Creates one single particle with a predefined	 * behaivoir and a varialbe color, shape and size	 * when start is called.	 *	 * @author Frank Bos and Jasper Kennis	 */	public class Emotion extends Emitter2D	{		private var _imgClass:ImageClass;		private var _zone:RectangleZone;		private var _position:Position;		private var _zone2:PointZone;		private var _velocity:Velocity;		private var _dzone:RectangleZone;		private var _deathZone:DeathZone;		private var _scaleImage:ScaleImageInit;		private var _emotions:Array;		private var _countDown:Array;		private var _afterCountDown:Array;		private var _boundingBox:BoundingBox;		private var _stage:Stage;		private var _bitmapData:BitmapData;		private var _textFormat:TextFormat;		private var _matrix:Matrix;		private var _bitmapDataZone:BitmapData;		private var _nextMessage:int;		private var _revivedParticle:Particle;		private var _disposableParticleStorage:Vector.<Particle>;		public function Emotion(stage):void		{			_stage = stage;			_nextMessage = 0;			// Populate the emotion array.			// Sad, Angry, Supprised, Happy			_emotions = new Array(new uint(0x57a3a0),new uint(0xe70414),new uint(0xefd42e),new uint(0xe82e9d));			// Populate countdown:			_countDown = new Array(10,9,8,7,6,5,4,3,2,1,0,"Welkom!");			// Add a counter to the emitter, which tells the emitter			// how many particles should be emitted every second. A			// steady counter continues to create particles.			counter = new Blast(5);			// Create a zone where the particles are created, and a			// spawning area.			updateSizes(stage.stageWidth,stage.stageHeight);			// Create a direction in which particles will move.			_velocity = new Velocity(new DiscZone(new Point(0,0),100,100));			addInitializer(_velocity);			// Give all particles a second to live.			addInitializer(new Lifetime(1));						// Add the move and drift action to the emitter.			addAction(new Move );			addAction( new Rotate );		}		/**		 * A custom start method that applies desireable changes		 * to the display object before creating it.		 */		public function extendedStart(age:int,sex:int,emotion:int):void		{			// Remove old _imgClass and add the new one			removeInitializer(_imgClass);						if (! sex)			{				// Female (round)				_imgClass = new ImageClass(Dot,[age * .1,_emotions[emotion]]);				addInitializer(_imgClass);			}			else			{				// Male (square)				_imgClass = new ImageClass(Rect,[age * .2,age * .2,_emotions[emotion]]);				addInitializer(_imgClass);				addInitializer(new RotateVelocity(0,2));			}			super.start();		}		/**		 * Update the sizes after the stage has been resized		 */		public function updateSizes(width:int,height:int):void		{			// Remove old size settings.			removeAction(_boundingBox);			removeInitializer(_position);			// Add new bounding box.			_boundingBox = new BoundingBox(0,0,width,height);			addAction(_boundingBox);			// Add new spawning area.			_zone = new RectangleZone(0,0,width,height);			_position = new Position(_zone);			addInitializer(_position);		}		/**		 * Gives particles life!!! After gathering emotions they start		 * moving into words. To do so they need a lifespan.		 */		public function startLiving():void		{			addEventListener(ParticleEvent.PARTICLE_DEAD,reincarnate);		}		/**		 * This function can be called on all particles to reset their		 * age to zero. Ahw, baby particles!		 */		private function revive(particle:Particle, i:int, v:Vector.<Particle>):Boolean		{			particle.revive();			particle.lifetime++;			return true;		}		/**		 * When a particle dies, move to it's next fase!		 */		private function reincarnate(e:ParticleEvent):void		{			// Only if all particals are ready for a new life, start it.			if (particles.length == particles.filter(readyForANewLife).length)			{				if (_countDown[_nextMessage])				{					//drawString( _bitmapDataZone, _countDown[_nextMessage] ,0 ,0 );					_nextMessage++;				}				else				{					_nextMessage = 0;				}			}		}		/**		 * Checks to see if a particle is ready for the next word		 */		private function readyForANewLife(e:Particle, i:int, v:Vector.<Particle>)		{			if (e.age == 1)			{				return true;			}			return false;		}	}}