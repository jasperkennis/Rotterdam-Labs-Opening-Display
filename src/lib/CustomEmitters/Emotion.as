package lib.CustomEmitters{	import flash.geom.Point;	import org.flintparticles.common.counters.Blast;	import org.flintparticles.common.displayObjects.Dot;	import org.flintparticles.common.displayObjects.Rect;	import org.flintparticles.common.particles.Particle;	import org.flintparticles.common.initializers.*;	import org.flintparticles.twoD.actions.*;	import org.flintparticles.twoD.emitters.Emitter2D;	import org.flintparticles.twoD.initializers.*;	import org.flintparticles.twoD.zones.*;	import org.flintparticles.threeD.initializers.RotateVelocity;	import org.flintparticles.twoD.actions.Rotate;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.display.Stage;	import flash.text.TextField;	import flash.geom.Matrix;	import flash.text.TextFormat;	import org.flintparticles.common.actions.Age;	import fl.motion.easing.Cubic;	import org.flintparticles.common.events.ParticleEvent;	/**	 * Creates one single particle with a predefined	 * behaivoir and a varialbe color, shape and size	 * when start is called.	 *	 * @author Frank Bos and Jasper Kennis	 */	public class Emotion extends Emitter2D	{		private var _imgClass:ImageClass;		private var _zone:RectangleZone;		private var _position:Position;		private var _zone2:PointZone;		private var _velocity:Velocity;		private var _dzone:RectangleZone;		private var _deathZone:DeathZone;		private var _scaleImage:ScaleImageInit;		private var _emotions:Array;		private var _boundingBox:BoundingBox;		private var _stage:Stage;		private var _bitmapData:BitmapData;		private var _textField:TextField;		private var _textFormat:TextFormat;		private var _matrix:Matrix;		private var _bitmapDataZone:BitmapData;		private var _easing:Function;		public function Emotion(stage)		{			_stage = stage;			_easing = Cubic.easeInOut;			// Populate the emotion array.			// Sad, Angry, Supprised, Happy			_emotions = new Array(new uint(0x57a3a0),new uint(0xe70414),new uint(0xefd42e),new uint(0xe82e9d));			// Add a counter to the emitter, which tells the emitter			// how many particles should be emitted every second. A			// steady counter continues to create particles.			counter = new Blast(10);			// Create a zone where the particles are created, and a			// spawning area.			updateSizes(stage.stageWidth,stage.stageHeight);			// Create a direction in which particles will move.			addInitializer(new Velocity(new DiscZone(new Point(0,0),100,100)));			// Add the move and drift action to the emitter.			addAction(new Move  );			addAction(new Rotate  );			// Format the text.			_textFormat = new TextFormat("Helvetica Neue",200);			_textFormat.bold = "condensed black";			_textField = new TextField  ;			_textField.width = 1000;			_textField.defaultTextFormat = _textFormat;			// Create a BitmapData object that will be used to			// draw a string to a bitmap to be used as a zone			// where particles should go.			_bitmapDataZone = new BitmapData(500,100,true,0x00FFFFFF);			// Draw somethingsomething as a test.			_bitmapDataZone.draw(_stage);			drawString(_bitmapDataZone,"WELKOM",0,0);			// To test output, draw it to the stage.			//_stage.addChild(new Bitmap(_bitmapDataZone));		}		/**		 * A custom start method that applies desireable changes		 * to the display object before creating it.		 */		public function extendedStart(age:int,sex:int,emotion:int):void		{			// Remove old _imgClass and add the new one			removeInitializer(_imgClass);			if (! sex)			{// Female (round)				_imgClass = new ImageClass(Dot,[age * .1,_emotions[emotion]]);				addInitializer(_imgClass);			}			else			{// Male (square)				_imgClass = new ImageClass(Rect,[age * .2,age * .2,_emotions[emotion]]);				addInitializer(_imgClass);				addInitializer(new RotateVelocity(0,2));			}			super.start();		}		/**		 * Update the sizes after the stage has been resized		 */		public function updateSizes(width:int,height:int):void		{			// Remove old size settings.			removeAction(_boundingBox);			removeInitializer(_position);			// Add new bounding box.			_boundingBox = new BoundingBox(0,0,width,height);			addAction(_boundingBox);			// Add new spawning area.			_zone = new RectangleZone(0,0,width,height);			_position = new Position(_zone);			addInitializer(_position);		}		/**		 * Convert a string to a BitmapData object.		 */		private function drawString(target:BitmapData,text:String,x:Number,y:Number):void		{			_textField.text = text;			_bitmapData = new BitmapData(_textField.width,_textField.height,true,0x00FFFFFF);			_bitmapData.draw(_textField);			_matrix = new Matrix  ;			_matrix.translate(x,y);			target.draw(_bitmapData,_matrix);			_bitmapData.dispose();		}		/**		 * Gives particles life!!! After gathering emotions they start		 * moving into words. To do so they need a lifespan.		 */		public function startLiving():void		{			particles.every(revive);			addInitializer(new Lifetime(1));			addAction(new Age(_easing));			addAction(new TweenToZone(new BitmapDataZone(_bitmapDataZone)));			addEventListener(ParticleEvent.PARTICLE_DEAD,tellMeAboutIt);		}				/**		 * This function can be called on all particles to reset their		 * age to zero. Ahw, baby particles!		 */		private function revive(e:Particle, i:int, v:Vector.<Particle>):Boolean		{			// All bogus:			v[i].lifetime = 1;			// trace(v[i].age = 100);			return true;		}						/**		 * Just a message from a dying particle...		 */		private function tellMeAboutIt(e:ParticleEvent):void		{			trace("I'm gonna die now. Goodbye:(");		}	}}